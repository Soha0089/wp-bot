const axios = require("axios");
const { log } = require('../scripts/helpers');

// Configuration constants
const CONFIG = {
  CACHE_DURATION: 30 * 60 * 1000, // 30 minutes
  REPLY_TIMEOUT: 30 * 60 * 1000, // 30 minutes
  REQUEST_TIMEOUT: 15000,
  MAX_RETRIES: 2,
  RETRY_DELAY_BASE: 1000,
  API_URL: "https://raw.githubusercontent.com/mahmudx7/exe/main/baseApiUrl.json",
  // Anti-spam settings
  USER_COOLDOWN: 30 * 1000, // 30 seconds per user
  GLOBAL_COOLDOWN: 5 * 1000, // 5 seconds global
  MAX_RESPONSES_PER_MINUTE: 3, // Max 3 responses per user per minute
  SPAM_THRESHOLD: 5 // Max 5 rapid messages before temporary block
};

// Cache for API base URL
let cachedBaseUrl = null;
let lastFetch = 0;

// OnReply storage (in-memory for this session)
const replyStates = new Map();

// Anti-spam tracking
const userCooldowns = new Map();
const userResponseCount = new Map();
const lastGlobalResponse = { timestamp: 0 };
const spamTracker = new Map();

// More specific trigger words to reduce false positives
const TRIGGERS = new Set([
  "jan", "jaan", "ржЬрж╛ржи", "hinata", "ai", "bot", "ржмржЯ",
  "dora", "ржбрзЛрж░рж╛"
  // Removed common words like "hey", "hi", "hello" to reduce spam
]);

// End conversation triggers
const END_TRIGGERS = new Set([
  'bye', 'ржмрж╛ржЗ', 'ржзржирзНржпржмрж╛ржж', 'thanks', 'end', 'stop', 'ржмржирзНржз', 'рж╢рзЗрж╖'
]);

// Random responses - cached for performance
const RANDOM_RESPONSES = [
  "ржмрж╛ржмрзБ ржХрж┐ ржЦржмрж░? ЁЯе║",
  "Boss ржмрж▓ boss! ЁЯШ╝", 
  "ржЖржорж╛ржХрзЗ ржбрж╛ржХрж▓рзЗ ржЖржорж┐ ржХрж┐ржирзНрждрзБ ржХрж┐рж╕ ржХрж░рзЗ ржжрзЗржмрзЛ ЁЯШШ",
  "ржХрж┐ ржмрж▓ржмрж╛? рж╕ржмрж╛рж░ рж╕рж╛ржоржирзЗ ржмрж▓ржмрж╛ ржирж╛ржХрж┐? ЁЯдн",
  "ржЖржорж┐ рждрзЛржорж╛ржХрзЗ ржнрж╛рж▓рзЛржмрж╛рж╕рж┐ ЁЯШШЁЯТХ",
  "ржХрзЗржоржи ржЖржЫрзЛ? ЁЯдЧ",
  "ржХрж┐ ржХрж░ржЫрзЛ ржПржЦржи? ЁЯдФ",
  "ржЖржорж╛рж░ рж╕рж╛ржерзЗ ржЧрж▓рзНржк ржХрж░рзЛ ЁЯТм",
  "рждрзБржорж┐ ржХрж┐ ржЖржорж╛рж░ рж╕рж╛ржерзЗ ржЦрзЗрж▓ржмрзЗ? ЁЯОо",
  "ржЖржЬ ржХрзЗржоржи ржжрж┐ржи ржХрж╛ржЯржЫрзЗ? тШАя╕П",
  "ржЖржорж┐ ржПржЦрж╛ржирзЗ ржЖржЫрж┐, ржХрж┐ ржмрж▓рждрзЗ ржЪрж╛ржУ? ЁЯТн"
];

const CHAT_RANDOM_RESPONSES = [
  "рж╣рзНржпрж╛ржБ ржмрж╛ржмрзБ, ржХрж┐ ржмрж▓ржмрзЗ? ЁЯе║",
  "ржмрж▓ ржмрж▓, ржЖржорж┐ рж╢рзБржиржЫрж┐! ЁЯСВ",
  "ржХрж┐ ржЦржмрж░? ржХрзЗржоржи ржЖржЫрзЛ? ЁЯШК",
  "ржЖржорж╛рж░ рж╕рж╛ржерзЗ ржХржерж╛ ржмрж▓рждрзЗ ржЪрж╛ржУ? ЁЯТХ",
  "рж╣рж╛ржЗ! ржЖржорж┐ ржПржЦрж╛ржирзЗ ржЖржЫрж┐ред ЁЯдЧ",
  "ржХрж┐ ржХрж░ржЫрзЛ? ржмрж▓ рждрзЛ! ЁЯдФ",
  "ржЖржорж┐ рждрзЛржорж╛рж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрж┐рж▓рж╛ржо! ЁЯТн"
];

/**
 * Anti-spam protection
 */
function isUserOnCooldown(userId) {
  const cooldownData = userCooldowns.get(userId);
  if (!cooldownData) return false;
  
  const now = Date.now();
  return now - cooldownData.lastResponse < CONFIG.USER_COOLDOWN;
}

function isGlobalCooldown() {
  const now = Date.now();
  return now - lastGlobalResponse.timestamp < CONFIG.GLOBAL_COOLDOWN;
}

function updateUserCooldown(userId) {
  const now = Date.now();
  userCooldowns.set(userId, { lastResponse: now });
  lastGlobalResponse.timestamp = now;
}

function checkUserSpam(userId) {
  const now = Date.now();
  const spam = spamTracker.get(userId) || { count: 0, lastReset: now, blocked: false };
  
  // Reset counter every minute
  if (now - spam.lastReset > 60000) {
    spam.count = 0;
    spam.lastReset = now;
    spam.blocked = false;
  }
  
  spam.count++;
  
  // Block if exceeding spam threshold
  if (spam.count > CONFIG.SPAM_THRESHOLD) {
    spam.blocked = true;
    spam.blockTime = now;
  }
  
  spamTracker.set(userId, spam);
  
  // Unblock after 5 minutes
  if (spam.blocked && now - spam.blockTime > 5 * 60 * 1000) {
    spam.blocked = false;
    spam.count = 0;
  }
  
  return spam.blocked;
}

function checkResponseLimit(userId) {
  const now = Date.now();
  const responseData = userResponseCount.get(userId) || { count: 0, lastReset: now };
  
  // Reset counter every minute
  if (now - responseData.lastReset > 60000) {
    responseData.count = 0;
    responseData.lastReset = now;
  }
  
  responseData.count++;
  userResponseCount.set(userId, responseData);
  
  return responseData.count > CONFIG.MAX_RESPONSES_PER_MINUTE;
}

/**
 * Fetch base API URL with caching
 */
async function getBaseApiUrl() {
  try {
    // Use cached URL if available and not expired
    if (cachedBaseUrl && (Date.now() - lastFetch < CONFIG.CACHE_DURATION)) {
      return cachedBaseUrl;
    }

    const response = await axios.get(CONFIG.API_URL, { 
      timeout: CONFIG.REQUEST_TIMEOUT 
    });
    
    if (response.data?.jan) {
      cachedBaseUrl = response.data.jan;
      lastFetch = Date.now();
      return cachedBaseUrl;
    }
    
    throw new Error("Invalid API response structure");
  } catch (error) {
    log(`Failed to fetch base API URL: ${error.message}`, 'error');
    
    // Fallback to cached URL if available
    if (cachedBaseUrl) {
      log('Using cached base URL as fallback', 'warning');
      return cachedBaseUrl;
    }
    
    throw new Error("Could not retrieve API base URL and no cache available");
  }
}

/**
 * Get bot response with retry logic
 */
async function getBotResponse(message, retries = CONFIG.MAX_RETRIES) {
  const cleanMessage = message.trim();
  if (!cleanMessage) {
    return getRandomResponse(RANDOM_RESPONSES);
  }

  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const baseUrl = await getBaseApiUrl();
      const encodedMessage = encodeURIComponent(cleanMessage);
      
      const response = await axios.get(
        `${baseUrl}/jan/font3/${encodedMessage}`,
        { 
          timeout: CONFIG.REQUEST_TIMEOUT,
          headers: {
            'User-Agent': 'WhatsApp-Bot/1.0',
            'Accept': 'application/json'
          }
        }
      );
      
      if (response.data?.message) {
        return response.data.message;
      }
      
      throw new Error("Invalid response format");
    } catch (error) {
      log(`API request attempt ${attempt + 1} failed: ${error.message}`, 'warning');
      
      if (attempt === retries) {
        log('All API attempts failed', 'error');
        return "ржЖржорж┐ ржПржЦржи ржПржХржЯрзБ ржмрзНржпрж╕рзНржд ржЖржЫрж┐ред ржкрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзЛред ЁЯШК";
      }
      
      // Exponential backoff
      await sleep(CONFIG.RETRY_DELAY_BASE * (attempt + 1));
    }
  }
}

/**
 * Check if message should trigger bot without prefix - More strict checking
 */
function shouldTriggerBot(messageBody) {
  const content = messageBody.toLowerCase().trim();
  const cleanedContent = content.replace(/[.,!?]+$/g, "");
  
  // More strict: Only trigger if message starts with trigger word or is exactly the trigger word
  return Array.from(TRIGGERS).some(trigger => {
    const lowerTrigger = trigger.toLowerCase();
    return cleanedContent === lowerTrigger || 
           cleanedContent.startsWith(lowerTrigger + " ");
  });
}

/**
 * Extract message content after trigger word
 */
function extractMessageAfterTrigger(messageBody) {
  const content = messageBody.toLowerCase().trim();
  const originalContent = messageBody.trim();
  
  for (const trigger of TRIGGERS) {
    const lowerTrigger = trigger.toLowerCase();
    const triggerWithSpace = lowerTrigger + " ";
    
    if (content.startsWith(triggerWithSpace)) {
      return originalContent.substring(triggerWithSpace.length).trim();
    } else if (content === lowerTrigger) {
      return "";
    }
  }
  
  return originalContent;
}

/**
 * Get random response from array
 */
function getRandomResponse(responses) {
  return responses[Math.floor(Math.random() * responses.length)];
}

/**
 * Set up conversation state
 */
function setupConversationState(userId, messageId) {
  replyStates.set(userId, {
    type: 'conversation',
    timestamp: Date.now(),
    messageId: messageId
  });
}

/**
 * Check if conversation state is valid
 */
function isValidConversationState(userId) {
  const replyState = replyStates.get(userId);
  
  if (!replyState || replyState.type !== 'conversation') {
    return { valid: false, expired: false };
  }
  
  const expired = Date.now() - replyState.timestamp > CONFIG.REPLY_TIMEOUT;
  if (expired) {
    replyStates.delete(userId);
    return { valid: false, expired: true };
  }
  
  return { valid: true, expired: false, state: replyState };
}

/**
 * Check if message is conversation end trigger
 */
function isEndTrigger(message) {
  const lowerMessage = message.toLowerCase();
  return Array.from(END_TRIGGERS).some(trigger => lowerMessage.includes(trigger));
}

/**
 * Send typing indicator
 */
async function sendTypingIndicator(message) {
  try {
    const chat = await message.getChat();
    await chat.sendStateTyping();
  } catch (error) {
    log(`Failed to send typing indicator: ${error.message}`, 'warning');
  }
}

/**
 * Sleep utility function
 */
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Clean up expired conversation states and cooldowns
 */
function cleanupExpiredStates() {
  const now = Date.now();
  
  // Clean up conversation states
  for (const [userId, state] of replyStates.entries()) {
    if (now - state.timestamp > CONFIG.REPLY_TIMEOUT) {
      replyStates.delete(userId);
    }
  }
  
  // Clean up old cooldowns
  for (const [userId, cooldown] of userCooldowns.entries()) {
    if (now - cooldown.lastResponse > CONFIG.USER_COOLDOWN * 10) {
      userCooldowns.delete(userId);
    }
  }
  
  // Clean up old response counts
  for (const [userId, data] of userResponseCount.entries()) {
    if (now - data.lastReset > 60000 * 5) {
      userResponseCount.delete(userId);
    }
  }
  
  // Clean up spam tracker
  for (const [userId, spam] of spamTracker.entries()) {
    if (now - spam.lastReset > 300000) { // 5 minutes
      spamTracker.delete(userId);
    }
  }
}

// Clean up expired states every 10 minutes
setInterval(cleanupExpiredStates, 10 * 60 * 1000);

module.exports = {
  config: {
    name: "bot2",
    aliases: ["jan", "jaan", "ржЬрж╛ржи", "hinata", "ai", "bot", "ржмржЯ", "dora", "ржбрзЛрж░рж╛"],
    version: "3.2",
    author: "MahMUD (Anti-spam by Assistant)",
    role: 0,
    description: { 
      en: "AI chatbot with anti-spam protection - responds to specific triggers",
      bn: "ржПржЖржЗ ржЪрзНржпрж╛ржЯржмржЯ рж╕рзНржкрзНржпрж╛ржо рж╕рзБрж░ржХрзНрж╖рж╛ рж╕рж╣ - ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржЯрзНрж░рж┐ржЧрж╛рж░рзЗ рж╕рж╛ржбрж╝рж╛ ржжрзЗржпрж╝"
    },
    category: "ai",
    guide: { 
      en: "Type 'jan [message]' or use specific trigger words. Has cooldown protection.",
      bn: "'ржЬрж╛ржи [ржмрж╛рж░рзНрждрж╛]' ржмрж╛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржЯрзНрж░рж┐ржЧрж╛рж░ рж╢ржмрзНржж ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред ржХрзБрж▓ржбрж╛ржЙржи рж╕рзБрж░ржХрзНрж╖рж╛ ржЖржЫрзЗред"
    },
    coolDown: 5 // Increased cooldown
  },

  onStart: async function({ message, args, client, prefix }) {
    try {
      const userId = message.from;
      
      // Anti-spam checks
      if (isUserOnCooldown(userId)) {
        await message.reply("ржПржХржЯрзБ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЛ! ржЦрзБржм рждрж╛ржбрж╝рж╛рж╣рзБржбрж╝рзЛ ржХрж░ржЫрзЛред тП│");
        return;
      }
      
      if (isGlobalCooldown()) {
        return; // Silent ignore during global cooldown
      }
      
      if (checkUserSpam(userId)) {
        await message.reply("рждрзБржорж┐ ржЦрзБржм ржмрзЗрж╢рж┐ рж╕рзНржкрзНржпрж╛ржо ржХрж░ржЫрзЛ! рзл ржорж┐ржирж┐ржЯ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЛред ЁЯЪл");
        return;
      }
      
      if (checkResponseLimit(userId)) {
        await message.reply("ржкрзНрж░рждрж┐ ржорж┐ржирж┐ржЯрзЗ рж╕рж░рзНржмрзЛржЪрзНржЪ рзйржЯрж┐ ржорзЗрж╕рзЗржЬ! ржПржХржЯрзБ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЛред тП░");
        return;
      }
      
      const userMessage = args.join(" ").trim();
      updateUserCooldown(userId);
      
      if (!userMessage) {
        const randomResponse = getRandomResponse(RANDOM_RESPONSES);
        setupConversationState(userId, message.id._serialized);
        
        await message.reply(`${randomResponse}\n\n_ржПржЦржи ржЖржорж╛рж░ рж╕рж╛ржерзЗ ржХржерж╛ ржмрж▓рзЛ, ржЖржорж┐ рж╕ржм рж╢рзБржиржЫрж┐... ЁЯСВ_\n_[Reply to continue conversation]_`);
        return;
      }

      await sendTypingIndicator(message);
      const botResponse = await getBotResponse(userMessage);
      
      setupConversationState(userId, message.id._serialized);
      await message.reply(`${botResponse}\n\n_Continue our conversation by replying to this message! ЁЯТм_`);
      
      log(`Bot2 AI response sent to ${userId}`, 'info');
    } catch (error) {
      log(`Bot2 error: ${error.message}`, 'error');
      await message.reply("ржжрзБржГржЦрж┐ржд, ржЖржорж┐ ржПржЦржи ржПржХржЯрзБ рж╕ржорж╕рзНржпрж╛ржпрж╝ ржЖржЫрж┐ред ржкрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзЛред ЁЯШФ");
    }
  },

  onReply: async function({ message, Reply, client }) {
    try {
      const userId = message.from;
      
      // Anti-spam checks for replies too
      if (checkUserSpam(userId)) {
        await message.reply("ржЦрзБржм рждрж╛ржбрж╝рж╛рж╣рзБржбрж╝рзЛ ржХрж░рзЛ ржирж╛! ржПржХржЯрзБ ржзрзИрж░рзНржп ржзрж░рзЛред ЁЯРМ");
        return;
      }
      
      const conversationCheck = isValidConversationState(userId);
      
      if (!conversationCheck.valid) {
        if (conversationCheck.expired) {
          await message.reply("ржХржерзЛржкржХржержирзЗрж░ рж╕ржоржпрж╝ рж╢рзЗрж╖! ржЖржмрж╛рж░ 'ржЬрж╛ржи' рж▓рж┐ржЦрзЗ ржирждрзБржи ржХржерзЛржкржХржержи рж╢рзБрж░рзБ ржХрж░рзЛред тП░");
        }
        return;
      }
      
      const userMessage = message.body.trim();
      
      if (!userMessage) {
        await message.reply("ржХрж┐ржЫрзБ рж▓рж┐ржЦрзЛ рждрзЛ! ЁЯдФ");
        return;
      }
      
      if (isEndTrigger(userMessage)) {
        replyStates.delete(userId);
        await message.reply("ржмрж╛ржЗ ржмрж╛ржЗ! ржЖржмрж╛рж░ ржХржерж╛ рж╣ржмрзЗред ЁЯСЛЁЯТХ\n\n_Conversation ended. Type 'jan' to start again._");
        return;
      }
      
      await sendTypingIndicator(message);
      const botResponse = await getBotResponse(userMessage);
      
      // Update timestamp to keep conversation alive
      setupConversationState(userId, message.id._serialized);
      
      await message.reply(`${botResponse}\n\n_Keep replying to continue our chat! ЁЯТм_`);
      
      log(`Bot2 onReply conversation with ${userId}`, 'info');
    } catch (error) {
      log(`Bot2 onReply error: ${error.message}`, 'error');
      await message.reply("ржХржерзЛржкржХржержирзЗ ржПржХржЯрзБ рж╕ржорж╕рзНржпрж╛ рж╣ржЪрзНржЫрзЗред ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзЛред ЁЯШЕ");
    }
  },

  onChat: async function({ client, message, config }) {
    try {
      if (!message.body || message.fromMe) return;
      
      const messageBody = message.body.trim();
      const userId = message.from;
      
      // Skip if message starts with any known prefix
      const botPrefix = config.bot?.prefix || "!";
      if (messageBody.startsWith(botPrefix)) return;
      
      // Anti-spam checks for onChat
      if (isUserOnCooldown(userId)) return; // Silent ignore during cooldown
      if (isGlobalCooldown()) return; // Silent ignore during global cooldown
      if (checkUserSpam(userId)) return; // Silent ignore if spamming
      if (checkResponseLimit(userId)) return; // Silent ignore if over limit
      
      // Check if should trigger bot (more strict now)
      if (!shouldTriggerBot(messageBody)) return;
      
      const userMessage = extractMessageAfterTrigger(messageBody);
      updateUserCooldown(userId);
      
      await sendTypingIndicator(message);
      
      const botResponse = userMessage 
        ? await getBotResponse(userMessage)
        : getRandomResponse(CHAT_RANDOM_RESPONSES);
      
      setupConversationState(userId, message.id._serialized);
      
      await message.reply(`${botResponse}\n\n_Reply to this message to continue our conversation! ЁЯЧия╕П_`);
      
      log(`Bot2 word-trigger response sent to ${userId}`, 'info');
    } catch (error) {
      log(`Bot2 onChat error: ${error.message}`, 'error');
    }
  }
};
