const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const fs = require('fs');
const fsExtra = require('fs-extra');
const path = require('path');
const config = require('./config.json');
const { loadCommands } = require('./scripts/cmdloadder');
const { loadEvents } = require('./scripts/eventsIndex');
const { initDatabase, log, formatUptime, trackCommand } = require('./scripts/helpers');
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cron = require('node-cron');

class WhatsAppBot {
    constructor() {
        this.config = config;
        this.commands = new Map();
        this.events = new Map();
        this.cooldowns = new Map();
        this.startTime = Date.now();
        this.isReady = false;
        this.retryCount = 0;
        this.maxRetries = 3;
        
        // Initialize WhatsApp client with improved configuration
        this.client = new Client({
            authStrategy: new LocalAuth({
                clientId: config.whatsapp.clientId || 'whatsapp-bot',
                dataPath: './auth_data'
            }),
            puppeteer: {
                headless: config.whatsapp.headless !== false,
                args: [
                    '--no-sandbox',
                    '--disable-setuid-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-accelerated-2d-canvas',
                    '--no-first-run',
                    '--no-zygote',
                    '--single-process',
                    '--disable-gpu',
                    '--disable-web-security',
                    '--disable-features=VizDisplayCompositor',
                    '--disable-extensions',
                    '--disable-background-timer-throttling',
                    '--disable-backgrounding-occluded-windows',
                    '--disable-renderer-backgrounding'
                ],
                timeout: 60000
            }
        });

        this.setupEventListeners();
        this.setupDashboard();
        this.setupAutoTasks();
    }

    async initialize() {
        try {
            log('üöÄ Starting WhatsApp Bot V2...', 'info');
            log(`üì± Client ID: ${this.config.whatsapp.clientId || 'whatsapp-bot'}`, 'info');
            
            // Initialize database
            await initDatabase();
            
            // Load commands and events
            await this.loadCommands();
            await this.loadEvents();
            
            // Initialize client with retry mechanism
            await this.initializeClientWithRetry();
            
        } catch (error) {
            log(`‚ùå Failed to initialize bot: ${error.message}`, 'error');
            log(`üìã Stack trace: ${error.stack}`, 'error');
            
            if (this.retryCount < this.maxRetries) {
                this.retryCount++;
                log(`üîÑ Retrying initialization (${this.retryCount}/${this.maxRetries})...`, 'warning');
                setTimeout(() => this.initialize(), 10000); // Wait 10 seconds before retry
            } else {
                log('‚ùå Max retries reached. Bot initialization failed.', 'error');
                process.exit(1);
            }
        }
    }

    async initializeClientWithRetry() {
        try {
            log('üîó Connecting to WhatsApp Web...', 'info');
            await this.client.initialize();
        } catch (error) {
            log(`‚ùå Client initialization failed: ${error.message}`, 'error');
            
            // Clear auth data if authentication fails repeatedly
            if (error.message.includes('Protocol error') || error.message.includes('Session closed')) {
                log('üßπ Clearing authentication data for fresh start...', 'warning');
                await this.clearAuthData();
            }
            
            throw error;
        }
    }

    async clearAuthData() {
        try {
            const authPath = path.join(__dirname, 'auth_data');
            if (await fsExtra.pathExists(authPath)) {
                await fsExtra.remove(authPath);
                log('‚úÖ Authentication data cleared', 'info');
            }
        } catch (error) {
            log(`‚ö†Ô∏è Failed to clear auth data: ${error.message}`, 'warning');
        }
    }

    setupEventListeners() {
        // QR Code generation with enhanced feedback
        this.client.on('qr', (qr) => {
            log('üì± QR Code received! Please scan with WhatsApp:', 'info');
            log('==========================================', 'info');
            qrcode.generate(qr, { small: true });
            log('==========================================', 'info');
            log('üí° Instructions:', 'info');
            log('   1. Open WhatsApp on your phone', 'info');
            log('   2. Tap Menu (‚ãÆ) > Linked Devices', 'info');
            log('   3. Tap "Link a Device"', 'info');
            log('   4. Scan the QR code above', 'info');
            log('‚è∞ QR Code expires in 20 seconds...', 'warning');
        });

        // Loading progress
        this.client.on('loading_screen', (percent, message) => {
            log(`üì∂ Loading: ${percent}% - ${message}`, 'info');
        });

        // Ready event with enhanced logging
        this.client.on('ready', async () => {
            this.isReady = true;
            this.retryCount = 0; // Reset retry count on successful connection
            
            log('üéâ WhatsApp Bot is ready!', 'success');
            log(`üìû Connected as: ${this.client.info.wid.user}`, 'info');
            log(`üì± Phone: ${this.client.info.phone}`, 'info');
            log(`üè∑Ô∏è Name: ${this.client.info.pushname}`, 'info');
            log(`üîã Battery: ${this.client.info.battery}%`, 'info');
            log(`üîå Plugged: ${this.client.info.plugged ? 'Yes' : 'No'}`, 'info');
            
            // Check for restart notification
            setTimeout(async () => {
                await this.checkRestartNotification();
            }, 3000);
        });

        // Authentication events with better feedback
        this.client.on('authenticated', () => {
            log('‚úÖ WhatsApp authenticated successfully!', 'success');
        });

        this.client.on('auth_failure', (msg) => {
            log(`‚ùå Authentication failed: ${msg}`, 'error');
            log('üí° Try clearing the auth_data folder and restart', 'warning');
        });

        // Disconnection handling with auto-reconnect
        this.client.on('disconnected', (reason) => {
            this.isReady = false;
            log(`üì¥ WhatsApp disconnected: ${reason}`, 'warning');
            
            if (this.config.autoRestart.enabled && this.retryCount < this.maxRetries) {
                this.retryCount++;
                const delay = this.config.autoRestart.delay || 5000;
                log(`üîÑ Attempting to reconnect in ${delay/1000} seconds... (${this.retryCount}/${this.maxRetries})`, 'info');
                
                setTimeout(async () => {
                    try {
                        await this.client.initialize();
                    } catch (error) {
                        log(`‚ùå Reconnection failed: ${error.message}`, 'error');
                    }
                }, delay);
            }
        });

        // Message handling
        this.client.on('message', async (message) => {
            if (this.isReady) {
                await this.handleMessage(message);
            }
        });

        // Message reply handling
        this.client.on('message', async (message) => {
            if (this.isReady && message.hasQuotedMsg) {
                await this.handleReply(message);
            }
        });

        // Group events
        this.client.on('group_join', async (notification) => {
            if (this.events.has('join')) {
                await this.events.get('join').execute(this.client, notification);
            }
        });

        this.client.on('group_leave', async (notification) => {
            if (this.events.has('leave')) {
                await this.events.get('leave').execute(this.client, notification);
            }
        });

        // Message revoke (delete)
        this.client.on('message_revoke_everyone', async (after, before) => {
            if (this.events.has('unsend')) {
                await this.events.get('unsend').execute(this.client, { after, before });
            }
        });

        // Error handling
        this.client.on('error', (error) => {
            log(`‚ùå Client error: ${error.message}`, 'error');
        });
    }

    async handleMessage(message) {
        try {
            // Skip if bot message or status
            if (message.fromMe || message.isStatus) return;

            // Get message details
            const chat = await message.getChat();
            const contact = await message.getContact();
            const isGroup = chat.isGroup;
            const prefix = await this.getEffectivePrefix(chat.id._serialized);

            // Check if message starts with prefix
            if (!message.body.startsWith(prefix)) {
                // Handle non-command messages if needed
                if (this.events.has('message')) {
                    await this.events.get('message').execute(this.client, message, { chat, contact, isGroup });
                }
                
                // Check for onChat handlers in commands
                for (const [, command] of this.commands) {
                    if (command.onChat) {
                        try {
                            await command.onChat({ message, client: this.client, config: this.config, chat, contact, isGroup });
                        } catch (error) {
                            log(`‚ùå Error in onChat for ${command.config.name}: ${error.message}`, 'error');
                        }
                    }
                }
                return;
            }

            // Parse command
            const args = message.body.slice(prefix.length).trim().split(/ +/);
            const commandName = args.shift().toLowerCase();

            // Get command
            const command = this.commands.get(commandName);
            if (!command) {
                if (!this.config.hideNotiMessage.commandNotFound) {
                    await message.reply(`‚ùå Command "${commandName}" not found. Use ${prefix}help for available commands.`);
                }
                return;
            }

            // Check permissions
            if (!await this.checkPermissions(command, message, chat, contact, isGroup)) {
                return;
            }

            // Check cooldown
            if (!await this.checkCooldown(command, message, contact)) {
                return;
            }

            // Execute command
            await command.onStart({
                message,
                args,
                chat,
                contact,
                isGroup,
                client: this.client,
                config: this.config,
                prefix
            });

            // Track command usage
            await trackCommand(contact.id._serialized);

            log(`‚úÖ Command executed: ${commandName} by ${contact.name || contact.number}`, 'info');

        } catch (error) {
            log(`‚ùå Error handling message: ${error.message}`, 'error');
            await message.reply('‚ùå An error occurred while processing your command.');
        }
    }

    async handleReply(message) {
        try {
            // Skip if bot message or status
            if (message.fromMe || message.isStatus) return;

            // Get quoted message
            const quotedMsg = await message.getQuotedMessage();
            if (!quotedMsg || !quotedMsg.fromMe) return; // Only handle replies to bot messages

            // Get message details
            const chat = await message.getChat();
            const contact = await message.getContact();
            const isGroup = chat.isGroup;

            // Check for onReply handlers in commands
            for (const [, command] of this.commands) {
                if (command.onReply) {
                    try {
                        await command.onReply({ 
                            message, 
                            Reply: quotedMsg,
                            client: this.client, 
                            config: this.config, 
                            chat, 
                            contact, 
                            isGroup 
                        });
                    } catch (error) {
                        log(`‚ùå Error in onReply for ${command.config.name}: ${error.message}`, 'error');
                    }
                }
            }

            log(`üì© Reply handled from ${contact.name || contact.number}`, 'info');

        } catch (error) {
            log(`‚ùå Error handling reply: ${error.message}`, 'error');
        }
    }

    async checkPermissions(command, message, chat, contact, isGroup) {
        const userRole = await this.getUserRole(contact, chat, isGroup);
        
        if (command.config.role > userRole) {
            const roleNames = ['User', 'Group Admin', 'Bot Owner'];
            await message.reply(`‚ùå You need ${roleNames[command.config.role]} permission to use this command.`);
            return false;
        }

        return true;
    }

    async checkCooldown(command, message, contact) {
        const cooldownKey = `${command.config.name}-${contact.id._serialized}`;
        const cooldownTime = command.config.coolDown * 1000;
        
        if (this.cooldowns.has(cooldownKey)) {
            const expirationTime = this.cooldowns.get(cooldownKey) + cooldownTime;
            
            if (Date.now() < expirationTime) {
                const timeLeft = (expirationTime - Date.now()) / 1000;
                await message.reply(`‚è∞ Please wait ${timeLeft.toFixed(1)} seconds before using this command again.`);
                return false;
            }
        }

        this.cooldowns.set(cooldownKey, Date.now());
        return true;
    }

    async getUserRole(contact, chat, isGroup) {
        // Check if bot owner
        if (this.config.adminBot.includes(contact.id._serialized)) {
            return 2;
        }

        // Check if group admin
        if (isGroup) {
            const participants = chat.participants;
            const participant = participants.find(p => p.id._serialized === contact.id._serialized);
            if (participant && participant.isAdmin) {
                return 1;
            }
        }

        return 0; // Regular user
    }

    async getEffectivePrefix(chatId) {
        try {
            const dbPath = path.join(__dirname, 'data', 'chat-prefixes.json');
            
            if (await fsExtra.pathExists(dbPath)) {
                const data = await fsExtra.readJSON(dbPath);
                return data[chatId] || this.config.bot.prefix;
            }
            return this.config.bot.prefix;
        } catch (error) {
            log(`‚ö†Ô∏è Error getting effective prefix: ${error.message}`, 'warning');
            return this.config.bot.prefix;
        }
    }

    async loadCommands() {
        const commands = await loadCommands();
        this.commands = commands;
        this.client.commands = commands; // Make commands accessible through client
        log(`üìã Loaded ${commands.size} commands`, 'info');
    }

    async loadEvents() {
        const events = await loadEvents();
        this.events = events;
        log(`üéâ Loaded ${events.size} events`, 'info');
    }

    setupDashboard() {
        if (!this.config.dashBoard.enabled) return;

        const app = express();
        const server = http.createServer(app);
        const io = socketIo(server);

        app.use(express.static('public'));
        app.use(express.json());

        app.get('/', (req, res) => {
            res.send(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>WhatsApp Bot Dashboard</title>
                    <script src="/socket.io/socket.io.js"></script>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
                        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
                        .online { background: #d4edda; color: #155724; }
                        .offline { background: #f8d7da; color: #721c24; }
                        .info { background: #d1ecf1; color: #0c5460; }
                    </style>
                </head>
                <body>
                    <h1>üêê WhatsApp Bot V2 Dashboard</h1>
                    <div id="status" class="status">Connecting...</div>
                    <div id="uptime" class="info">Uptime: Loading...</div>
                    <div id="commands" class="info">Commands: Loading...</div>
                    <div id="phone" class="info">Phone: Loading...</div>
                    <script>
                        const socket = io();
                        socket.on('status', (data) => {
                            const statusEl = document.getElementById('status');
                            statusEl.innerHTML = data.status;
                            statusEl.className = 'status ' + (data.status.includes('üü¢') ? 'online' : 'offline');
                            document.getElementById('uptime').innerHTML = 'Uptime: ' + data.uptime;
                            document.getElementById('commands').innerHTML = 'Commands: ' + data.commandCount;
                            document.getElementById('phone').innerHTML = 'Phone: ' + (data.phone || 'Not connected');
                        });
                    </script>
                </body>
                </html>
            `);
        });

        io.on('connection', (socket) => {
            const sendStatus = () => {
                socket.emit('status', {
                    status: this.isReady ? 'üü¢ Connected' : 'üî¥ Disconnected',
                    uptime: formatUptime(Date.now() - this.startTime),
                    commandCount: this.commands.size,
                    phone: this.client.info ? this.client.info.wid.user : 'N/A'
                });
            };
            
            sendStatus();
            
            // Send status updates every 5 seconds
            const interval = setInterval(sendStatus, 5000);
            
            socket.on('disconnect', () => {
                clearInterval(interval);
            });
        });

        server.listen(this.config.dashBoard.port, () => {
            log(`üìä Dashboard available at http://localhost:${this.config.dashBoard.port}`, 'info');
        });
    }

    setupAutoTasks() {
        // Auto restart
        if (this.config.autoRestart.enabled) {
            cron.schedule(this.config.autoRestart.schedule || '0 2 * * *', () => {
                log('üîÑ Scheduled restart initiated', 'info');
                process.exit(0);
            });
        }

        // Uptime monitoring
        if (this.config.autoUptime.enabled) {
            setInterval(() => {
                const uptime = formatUptime(Date.now() - this.startTime);
                log(`‚è∞ Bot uptime: ${uptime}`, 'info');
            }, this.config.autoUptime.interval || 3600000);
        }
    }

    async checkRestartNotification() {
        try {
            const restartCommand = this.commands.get('restart');
            if (restartCommand && typeof restartCommand.checkRestart === 'function') {
                await restartCommand.checkRestart(this.client);
            }
        } catch (error) {
            log(`‚ö†Ô∏è Error checking restart notification: ${error.message}`, 'warning');
        }
    }
}

// Initialize and start bot
const bot = new WhatsAppBot();
bot.initialize();

// Handle process termination gracefully
process.on('SIGINT', () => {
    log('üëã Bot shutting down gracefully...', 'info');
    if (bot.client) {
        bot.client.destroy();
    }
    process.exit(0);
});

process.on('SIGTERM', () => {
    log('üëã Bot terminated...', 'info');
    if (bot.client) {
        bot.client.destroy();
    }
    process.exit(0);
});

// Handle uncaught errors
process.on('unhandledRejection', (reason, promise) => {
    log(`‚ùå Unhandled Rejection at: ${promise}, reason: ${reason}`, 'error');
});

process.on('uncaughtException', (error) => {
    log(`‚ùå Uncaught Exception: ${error.message}`, 'error');
    log(`üìã Stack: ${error.stack}`, 'error');
});
